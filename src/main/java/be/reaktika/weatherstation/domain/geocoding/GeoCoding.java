/* This code was generated by Akka Serverless tooling.
 * As long as this file exists it will not be re-generated.
 * You are free to make changes to this file.
 */
package be.reaktika.weatherstation.domain.geocoding;

import be.reaktika.weatherstation.domain.WeatherStationPublish;
import be.reaktika.weatherstation.domain.aggregations.GeoCodingService;
import be.reaktika.weatherstation.domain.aggregations.WeatherStationAggregation;
import com.akkaserverless.javasdk.ServiceCallRef;
import com.akkaserverless.javasdk.SideEffect;
import com.akkaserverless.javasdk.valueentity.ValueEntityContext;
import com.google.protobuf.Empty;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/** A value entity. */
public class GeoCoding extends AbstractGeoCoding {
  @SuppressWarnings("unused")
  private static final Logger logger = LoggerFactory.getLogger(GeoCoding.class);
  private final String entityId;
  private final ServiceCallRef<WeatherstationGeocoding.CountryMeasurements> measurementsPublisher;


  public GeoCoding(ValueEntityContext context) {
    this.entityId = context.entityId();
    measurementsPublisher = context.serviceCallFactory()
            .lookup("be.reaktika.weatherstation.domain.geocoding.publishing.GeoCodingPublishService",
                    "PublishMeasurements",
                    WeatherstationGeocoding.CountryMeasurements.class);
  }

  @Override
  public WeatherstationGeocoding.GeoCodingState emptyState() {
    return WeatherstationGeocoding.GeoCodingState.getDefaultInstance();
  }

  @Override
  public Effect<Empty> registerData(WeatherstationGeocoding.GeoCodingState currentState, WeatherStationAggregation.AddToAggregationCommand command) {
    if (command.getWeatherdata().getTemperaturesList().isEmpty() && command.getWeatherdata().getWindspeedsList().isEmpty()){
      return stationRegistered(command.getWeatherdata(), currentState);
    }
    if (!command.getWeatherdata().getTemperaturesList().isEmpty()){
      return processTemperatureAdded(command.getWeatherdata(), currentState);
    }
    return processWindspeedAdded(command.getWeatherdata(), currentState);
  }

  private Effect<Empty> stationRegistered(WeatherStationPublish.WeatherStationData data, WeatherstationGeocoding.GeoCodingState currentState){
    logger.info("station registered: reverse geocoding the location to find the country");

    var reply = effects().reply(Empty.getDefaultInstance());
    var country = GeoCodingService.getInstance().getCountryCode(data.getLatitude(), data.getLongitude());

    logger.info("registered " + data.getStationId() + " in country " + country);
    country.ifPresent(c -> {
      logger.info("updating state: " + data.getStationId() + "-> " + c);
      var stateBuilder = WeatherstationGeocoding.GeoCodingState.newBuilder(currentState);
      stateBuilder.putStationIdToCountry(data.getStationId(), c);
      effects().updateState(stateBuilder.build());

      var toPublish = WeatherstationGeocoding.CountryMeasurements
              .newBuilder().setCountry(c);
      reply.addSideEffects(SideEffect.of(measurementsPublisher.createCall(toPublish.build())));
    });


    return reply;
  }

  private Effect<Empty> processTemperatureAdded(WeatherStationPublish.WeatherStationData data, WeatherstationGeocoding.GeoCodingState currentState){
    logger.info("temperature added for " + data + " with state " + currentState);
    var country = currentState.getStationIdToCountryOrDefault(data.getStationId(),"NONE");
    logger.info("country for " + data.getStationId() + " is " + country);
    var builder = WeatherstationGeocoding.CountryMeasurements.newBuilder();
    builder.setCountry(country);
    if (!country.equals("NONE")) {
      data.getTemperaturesList().forEach(t -> {
        builder.addTemperatures(WeatherStationAggregation.TemperatureMeasurement.newBuilder()
                .setStationId(data.getStationId())
                .setMeasuredTemperature(t.getTemperatureCelcius())
                .setMeasurementTime(t.getMeasurementTime()));
      });
      logger.info("forwarding temperatures for country " + country);
      return effects().forward(measurementsPublisher.createCall(builder.build()));
    } else {
      logger.warn("no country found for station " + data.getStationId());
      return effects().reply(Empty.getDefaultInstance());
    }
  }

  private Effect<Empty> processWindspeedAdded(WeatherStationPublish.WeatherStationData data, WeatherstationGeocoding.GeoCodingState currentState){
    logger.info("windspeeds added for " + data + " with state " + currentState);
    return effects().forward(measurementsPublisher.createCall(WeatherstationGeocoding.CountryMeasurements.getDefaultInstance()));
  }
}
